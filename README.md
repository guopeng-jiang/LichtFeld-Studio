# LichtFeld-Studio Installation Guide for Windows 11

This guide provides detailed, step-by-step instructions to compile and run LichtFeld-Studio on a Windows 11 machine. It is tailored to a specific environment and includes solutions to common compilation errors encountered during the process.

## 1. Prerequisites
Before you begin, ensure your system meets the following requirements:

- Operating System: Windows 11.
- Visual Studio: Visual Studio 2022 (or 2019) with the "Desktop development with C++" workload installed.
- Git: Required for cloning the repository. You can download it from git-scm.com.
- CMake: Version 3.20 or higher. You can check your version by running cmake --version in a command prompt.
- vcpkg: A C++ package manager from Microsoft. It should be installed, and the VCPKG_ROOT system environment variable must be set to its location (e.g., D:\vcpkg).
- CUDA Toolkit:
Recommended Version: 12.8. The project specifies a LibTorch version built for CUDA 12.8 (cu128). Using a newer version like 13.0 will likely cause compilation errors. This guide assumes you are using CUDA 12.8.
If you have multiple CUDA versions installed, ensure your system's CUDA_PATH environment variable points to the 12.8 installation.

IMPORTANT NOTE: All build commands must be executed from the x64 Native Tools Command Prompt for Visual Studio. Do not use a standard Command Prompt or PowerShell, as it will not be able to find the necessary C++ compiler (cl.exe).

## 2. Installation Steps
### Step 2.1: Clone the Repository
Open the x64 Native Tools Command Prompt and run the following commands to clone the repository and navigate into the project directory.
```Bash
git clone https://github.com/MrNeRF/LichtFeld-Studio
cd LichtFeld-Studio
```

### Step 2.2: Create Dependency Directories
Create the required folders for the external libraries.
```Bash
mkdir external
mkdir external\debug
mkdir external\release
```

### Step 2.3: Download and Extract LibTorch
The project requires both debug and release builds of LibTorch 2.7.0 for CUDA 12.8.
Download and extract the Debug version:

```Bash
curl -L -o libtorch-debug.zip https://download.pytorch.org/libtorch/cu128/libtorch-win-shared-with-deps-debug-2.7.0%2Bcu128.zip
tar -xf libtorch-debug.zip -C external\debug
del libtorch-debug.zip
```

Download and extract the Release version:

```Bash
curl -L -o libtorch-release.zip https://download.pytorch.org/libtorch/cu128/libtorch-win-shared-with-deps-2.7.0%2Bcu128.zip
tar -xf libtorch-release.zip -C external\release
del libtorch-release.zip
```

### Step 2.4: Configure the Build with CMake
Now, run CMake to generate the build files.
Note: If this step fails with a vcpkg error, see the troubleshooting section below.

```Bash
cmake -B build -DCMAKE_BUILD_TYPE=Release -G Ninja
```

### Step 2.5: Build the Project
Finally, compile the project using the build files generated by CMake. This process will take several minutes.

```Bash
cmake --build build
```
If the command completes without errors, the LichtFeld-Studio.exe executable will be located in the D:\LichtFeld-Studio\build directory.

## 3. Troubleshooting Common Errors
- Error: Cannot find compiler 'cl.exe' in PATH

Cause: You are not using the correct command prompt.

Solution: Close your current terminal and open the "x64 Native Tools Command Prompt for VS 2022" (or your VS version) from the Start Menu. Navigate back to your project directory and run the cmake command again.

- Error: vcpkg install failed... failed togit showversions/baseline.json

Cause: Your local vcpkg repository is out of date and cannot find the specific library versions required by the project.

Solution: Update your vcpkg installation by running these commands from your VCPKG_ROOT directory:

```Bash
cd /d D:\vcpkg  # Replace with your VCPKG_ROOT path
git pull
.\bootstrap-vcpkg.bat
```
After updating, delete the build folder in your LichtFeld-Studio directory and re-run the cmake configuration command.

- Error: namespace "cub" has no member "Max"

Cause: This is a known incompatibility between newer CUDA versions (13.0+) and the version of the CUB library expected by this project's dependencies (LibTorch cu128).

Solution: The most reliable solution is to use CUDA Toolkit 12.8. Change your system's environment variables (CUDA_PATH) to point to your CUDA 12.8 installation and restart your command prompt before running the build again.

# Structure from Motion (SfM) with COLMAP

### Extra step for inputs that are videos

This step is for custom inputs. If you have a video, please extract it into image frames. This can be done with FFMPEG. Below is a template for the ffmpeg command.
```
ffmpeg -i input_data/file.mp4 -r 1/1 input_data/$filename%03d.png
```

Now, with a collection of images of a scene, you would need to put the **set** of input images into the `input_data/<your_image_collection>/input` folder. Eg. `fern/input`

Taking 2 collections (fern and toy_truck) of input images as an example, below is the File Structure **requirements** before running `convert.py`. You would need to create these folders.
```
üìÇgaussian-splatting-Windows.git/ # this is root
‚îú‚îÄ‚îÄ üìÇinput_data/
‚îÇ	‚îú‚îÄ‚îÄ üìÇfern/
‚îÇ	‚îÇ	‚îú‚îÄ‚îÄ üìÇinput/
‚îÇ	‚îÇ	‚îÇ	‚îú‚îÄ‚îÄ üñºÔ∏èimage1.jpg
‚îÇ	‚îÇ	‚îÇ	‚îú‚îÄ‚îÄ üñºÔ∏èimage2.jpg
‚îÇ	‚îÇ	‚îÇ	‚îÇ...
‚îÇ	‚îú‚îÄ‚îÄ üìÇtoy_truck/
‚îÇ	‚îÇ	‚îú‚îÄ‚îÄ üìÇinput/
‚îÇ	‚îÇ	‚îÇ	‚îú‚îÄ‚îÄ üñºÔ∏èimage1.jpg
‚îÇ	‚îÇ	‚îÇ	‚îú‚îÄ‚îÄ üñºÔ∏èimage2.jpg
‚îÇ	‚îÇ	‚îÇ	‚îÇ...
‚îÇ ‚îÇ...
‚îÇ...
```

Now, using `fern` as an example, 
```
python convert.py -s input_data/fern --colmap_executable COLMAP-3.8-windows-cuda\COLMAP.bat
```
Below is the template:
```
python convert.py -s <your_input_dir> --colmap_executable COLMAP-3.8-windows-cuda\COLMAP.bat
```


Below is the original documentation
---------------------------------------------------------------------------------------------------

<div align="center"><img src="src/visualizer/gui/assets/logo/lichtfeld-logo-white.svg" alt="LichtFeld Studio" height="60"></div>

<div align="center">
**A high-performance C++ and CUDA implementation of 3D Gaussian Splatting**

[![Discord](https://img.shields.io/badge/Discord-Join%20Us-7289DA?logo=discord&logoColor=white)](https://discord.gg/TbxJST2BbC)
[![Website](https://img.shields.io/badge/Website-Lichtfeld%20Studio-blue)](https://mrnerf.github.io/lichtfeld-studio-web/)
[![Papers](https://img.shields.io/badge/Papers-Awesome%203DGS-orange)](https://mrnerf.github.io/awesome-3D-gaussian-splatting/)
[![License](https://img.shields.io/badge/License-GPLv3-green.svg)](LICENSE)
[![CUDA](https://img.shields.io/badge/CUDA-12.8+-76B900?logo=nvidia&logoColor=white)](https://developer.nvidia.com/cuda-downloads)
[![C++](https://img.shields.io/badge/C++-23-00599C?logo=cplusplus&logoColor=white)](https://en.cppreference.com/w/cpp/23)

<img src="docs/viewer_demo.gif" alt="3D Gaussian Splatting Viewer" width="85%"/>

[**Quick Start**](#quick-start) ‚Ä¢
[**Installation**](#installation) ‚Ä¢
[**Usage**](#usage) ‚Ä¢
[**Results**](#benchmark-results) ‚Ä¢
[**Community**](#community--support)

</div>

---

## Support LichtFeld Studio Development

LichtFeld Studio is a free, open-source implementation of 3D Gaussian Splatting that pushes the boundaries of real-time rendering performance.

**Why Your Support Matters**:
This project requires significant time and resources to develop and maintain. 

Unlike commercial alternatives that can cost thousands in licensing fees, LichtFeld Studio remains completely free and open. Your contribution helps ensure it stays that way while continuing to evolve with the latest research.

Whether you're using it for research, production, or learning, your support enables us to dedicate more time to making LichtFeld Studio faster, more powerful, and accessible to everyone in the 3D graphics community.

[![PayPal](https://img.shields.io/badge/PayPal-00457C?style=for-the-badge&logo=paypal&logoColor=white)](https://paypal.me/MrNeRF)
[![Support on Donorbox](https://img.shields.io/badge/Donate-Donorbox-27A9E1?style=for-the-badge)](https://donorbox.org/lichtfeld-studio)

---

## Overview

LichtFeld Studio is a high-performance implementation of 3D Gaussian Splatting that leverages modern C++23 and CUDA 12.8+ for optimal performance. Built with a modular architecture, it provides both training and real-time visualization capabilities for neural rendering research and applications.

### Key Features

- **2.4x faster rasterization** (winner of first bounty by Florian Hahlbohm)
- **MCMC optimization strategy** for improved convergence
- **Real-time interactive viewer** with OpenGL rendering
- **Modular architecture** with separate core, training, and rendering components
- **Multiple rendering modes** including RGB, depth, and combined views
- **Bilateral grid appearance modeling** for handling per-image variations

## Community & Support

Join our growing community for discussions, support, and updates:

- **[Discord Community](https://discord.gg/TbxJST2BbC)** - Get help, share results, and discuss development
- **[LichtFeld Studio FAQ](docs/docs/faq.md)** - Frequently Asked Questions about LichtFeld Studio
- **[Website](https://mrnerf.com)** - Visit our website for more resources
- **[Awesome 3D Gaussian Splatting](https://mrnerf.github.io/awesome-3D-gaussian-splatting/)** - Comprehensive paper list
- **[@janusch_patas](https://twitter.com/janusch_patas)** - Follow for the latest updates

## Active Bounties

### Fourth Bounty: Automatic Per-Scene Hyperparameter Optimization
**üí∞ $2,430** | [Issue #443](https://github.com/MrNeRF/LichtFeld-Studio/issues/443)  
**üìÖ Deadline:** October 12, 2025 at 11:59 PM PST

### Third Bounty: Follow-up to Bounty #002
**üí∞ $500** | [Issue #421](https://github.com/MrNeRF/LichtFeld-Studio/issues/421)  
**üìÖ Deadline:** None (open-ended)

## Quick Start

```bash
# Clone and build (Linux)
git clone https://github.com/MrNeRF/LichtFeld-Studio
cd LichtFeld-Studio

# Download LibTorch
wget https://download.pytorch.org/libtorch/cu128/libtorch-cxx11-abi-shared-with-deps-2.7.0%2Bcu128.zip  
unzip libtorch-cxx11-abi-shared-with-deps-2.7.0+cu128.zip -d external/

# Build
cmake -B build -DCMAKE_BUILD_TYPE=Release -G Ninja
cmake --build build -- -j$(nproc)

# Train on sample data
./build/LichtFeld-Studio -d data/garden -o output/garden --eval
```

## Installation

### Requirements

#### Software
- **OS**: Linux (Ubuntu 22.04+) or Windows
- **CMake**: 3.30 or higher
- **Compiler**: C++23 compatible (GCC 14+ or Clang 17+)
- **CUDA**: 12.8 or higher (required)
  
- **LibTorch**: 2.7.0 (setup instructions below)
- **vcpkg**: For dependency management

#### Hardware
- **GPU**: NVIDIA GPU with compute capability 7.5+
- **VRAM**: Minimum 8GB recommended
- **Tested GPUs**: RTX 4090, RTX A5000, RTX 3090Ti, A100, RTX 2060 SUPER

### Build Instructions

<details>
<summary><b>Linux Build</b></summary>

```bash
# Set up vcpkg (one-time setup)
git clone https://github.com/microsoft/vcpkg.git
cd vcpkg && ./bootstrap-vcpkg.sh -disableMetrics && cd ..

## If you want you can specify vcpkg locally without globally setting env variable (see -DCMAKE_TOOLCHAIN_FILE version)
export VCPKG_ROOT=/path/to/vcpkg  # Add to ~/.bashrc

# Clone repository
git clone https://github.com/MrNeRF/LichtFeld-Studio
cd LichtFeld-Studio

# Download LibTorch 2.7.0 with CUDA 12.8
wget https://download.pytorch.org/libtorch/cu128/libtorch-cxx11-abi-shared-with-deps-2.7.0%2Bcu128.zip  
unzip libtorch-cxx11-abi-shared-with-deps-2.7.0+cu128.zip -d external/
rm libtorch-cxx11-abi-shared-with-deps-2.7.0+cu128.zip

# Build
cmake -B build -DCMAKE_BUILD_TYPE=Release -G Ninja

## Or if you want you can specify your own vcpkg 
# cmake -B build -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE="<path-to-vcpkg>/scripts/buildsystems/vcpkg.cmake" -G Ninja 

cmake --build build -- -j$(nproc)
```

</details>

<details>
<summary><b>Windows Build</b></summary>
    
note: [Detailed instructions here](https://github.com/MrNeRF/LichtFeld-Studio/blob/master/docs/docs/installation/building/windows.md)

Run in <u>**x64 native tools command prompt for VS**</u>:

```bash
# Set up vcpkg (one-time setup)
git clone https://github.com/microsoft/vcpkg.git
cd vcpkg && .\bootstrap-vcpkg.bat -disableMetrics && cd ..

## If you want you can specify vcpkg locally without globally setting env variable (see -DCMAKE_TOOLCHAIN_FILE version)
set VCPKG_ROOT=%CD%\vcpkg

# Clone repository
git clone https://github.com/MrNeRF/LichtFeld-Studio
cd LichtFeld-Studio

# Create directories
if not exist external mkdir external
if not exist external\debug mkdir external\debug
if not exist external\release mkdir external\release

# Download LibTorch (Debug)
curl -L -o libtorch-debug.zip https://download.pytorch.org/libtorch/cu128/libtorch-win-shared-with-deps-debug-2.7.0%2Bcu128.zip
tar -xf libtorch-debug.zip -C external\debug
del libtorch-debug.zip

# Download LibTorch (Release)
curl -L -o libtorch-release.zip https://download.pytorch.org/libtorch/cu128/libtorch-win-shared-with-deps-2.7.0%2Bcu128.zip
tar -xf libtorch-release.zip -C external\release
del libtorch-release.zip

# Build 

## Or if you want you can specify your own vcpkg 
# cmake -B build -DCMAKE_BUILD_TYPE=Release -G ninja -DCMAKE_TOOLCHAIN_FILE="<path-to-vcpkg>/scripts/buildsystems/vcpkg.cmake"

# Ninja should be included with Visual Studio installation, 
# if not you can either install it, 
# or ignore this flag and use native generator - Building time might be extended
cmake -B build -DCMAKE_BUILD_TYPE=Release -G Ninja

cmake --build build -j
```

</details>

<details>
<summary><b>Docker Build</b></summary>

```bash
# Build and start container
./docker/run_docker.sh -bu 12.8.0

# Build without cache
./docker/run_docker.sh -n

# Stop containers
./docker/run_docker.sh -c
```

</details>

### Compiler Setup

<details>
<summary><b>Ubuntu 24.04+ (GCC 14)</b></summary>

```bash
# Install GCC 14
sudo apt update
sudo apt install gcc-14 g++-14 gfortran-14

# Set as default
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-14 60
sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-14 60
sudo update-alternatives --config gcc
sudo update-alternatives --config g++
```

</details>

<details>
<summary><b>Ubuntu 22.04 (Build GCC 14 from source)</b></summary>

```bash
# Install dependencies
sudo apt install build-essential libmpfr-dev libgmp3-dev libmpc-dev -y

# Download and build GCC
wget http://ftp.gnu.org/gnu/gcc/gcc-14.1.0/gcc-14.1.0.tar.gz
tar -xf gcc-14.1.0.tar.gz
cd gcc-14.1.0

# Configure and build (1-2 hours)
./configure --prefix=/usr/local/gcc-14.1.0 --enable-languages=c,c++ --disable-multilib
make -j$(nproc)
sudo make install

# Set up alternatives
sudo update-alternatives --install /usr/bin/gcc gcc /usr/local/gcc-14.1.0/bin/gcc 14
sudo update-alternatives --install /usr/bin/g++ g++ /usr/local/gcc-14.1.0/bin/g++ 14
```

</details>

## Usage
The preferred way to use LichtFeld Studio is to import your data (undistorted images + pointcloud + camera locations) in COLMAP format.  
Have a look at these 2 introduction videos on how to get your images ready for use in LichtFeld Studio:

[![LichtFeld Studio Beginner Tutorial - Using Reality Scan to create a  dataset for LichtFeld Studio](http://img.youtube.com/vi/JWmkhTlbDvg/0.jpg)](http://www.youtube.com/watch?v=JWmkhTlbDvg "Watch on youtube")
[![LichtFeld Studio Beginner Tutorial - Using Colmap to create a  dataset for LichtFeld Studio](http://img.youtube.com/vi/-3TBbukYN00/0.jpg)](https://www.youtube.com/watch?v=-3TBbukYN00 "Watch on youtube")


### Dataset Preparation

Download and extract the Tanks & Trains dataset:

```bash
wget https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/datasets/input/tandt_db.zip
unzip tandt_db.zip -d data/
```

### Training

Basic training:
```bash
./build/LichtFeld-Studio -d data/garden -o output/garden
```

Training with evaluation and visualization:
```bash
./build/LichtFeld-Studio \
    -d data/garden \
    -o output/garden \
    --eval \
    --save-eval-images \
    --render-mode RGB_D \
    -i 30000
```

MCMC strategy with limited Gaussians:
```bash
./build/LichtFeld-Studio \
    -d data/garden \
    -o output/garden \
    --strategy mcmc \
    --max-cap 500000
```

### Command-Line Options

#### Required
- `-d, --data-path [PATH]` - Path to training data with COLMAP reconstruction

#### Training Configuration
- `-o, --output-path [PATH]` - Output directory (default: `./output`)
- `-i, --iter [NUM]` - Training iterations (default: 30000)
- `-r, --resize_factor [NUM]` - Image resolution factor (default: 1)
- `--strategy [mcmc|default]` - Optimization strategy (default: `mcmc`)
- `--max-cap [NUM]` - Maximum Gaussians for MCMC (default: 1000000)

#### Evaluation
- `--eval` - Enable evaluation during training
- `--save-eval-images` - Save evaluation images
- `--test-every [NUM]` - Test/validation split ratio (default: 8)

#### Visualization
- `--headless` - Run without GUI (terminal-only mode)

#### Advanced Options
- `--bilateral-grid` - Enable appearance modeling
- `--steps-scaler [NUM]` - Scale training steps for multiple checkpoints
- See `--help` for complete list of options

### LPIPS Model Details

The implementation uses `weights/lpips_vgg.pt`, exported from `torchmetrics` with:
- **Network**: VGG with ImageNet pretrained weights
- **Input range**: [-1, 1] (conversion handled internally)
- **Normalization**: Included in model

## Project Architecture

```
LichtFeld-Studio/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ core/          # Foundation (data structures, utilities)
‚îÇ   ‚îú‚îÄ‚îÄ geometry/      # Geometric operations
‚îÇ   ‚îú‚îÄ‚îÄ loader/        # Dataset loading (COLMAP, PLY, Blender)
‚îÇ   ‚îú‚îÄ‚îÄ training/      # Training pipeline and strategies
‚îÇ   ‚îú‚îÄ‚îÄ rendering/     # CUDA/OpenGL rendering
‚îÇ   ‚îî‚îÄ‚îÄ visualizer/    # Interactive GUI
‚îú‚îÄ‚îÄ gsplat/            # Optimized rasterization backend
‚îú‚îÄ‚îÄ fastgs/            # Fast Gaussian splatting kernels
‚îî‚îÄ‚îÄ parameter/         # JSON configuration files
```

## Contributing

We welcome contributions! See our [Contributing Guidelines](CONTRIBUTING.md).

### Getting Started
- Check issues labeled **good first issue**
- Join our [Discord](https://discord.gg/TbxJST2BbC) for discussions
- Use the pre-commit hook: `cp tools/pre-commit .git/hooks/`

### Development Requirements
- C++23 compatible compiler (GCC 14+ or Clang 17+)
- CUDA 12.8+ for GPU development
- Apply `clang-format` for code style

## Acknowledgments

This implementation builds upon:
- **[gsplat](https://github.com/nerfstudio-project/gsplat)** - Optimized CUDA rasterization backend
- **[3D Gaussian Splatting](https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/)** - Original work by Kerbl et al.

## Citation

```bibtex
@software{lichtfeld2025,
  author    = {LichtFeld Studio},
  title     = {A high-performance C++ and CUDA implementation of 3D Gaussian Splatting},
  year      = {2025},
  url       = {https://github.com/MrNeRF/LichtFeld-Studio}
}
```

## License

This project is licensed under GPLv3. See [LICENSE](LICENSE) for details.

---

<div align="center">

**Connect with us:** [Website](https://mrnerf.com) ‚Ä¢ [Discord](https://discord.gg/TbxJST2BbC) ‚Ä¢ [Twitter](https://twitter.com/janusch_patas)

</div>
